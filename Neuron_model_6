#Notes

#Plot number of released vesicles, number of docked vesicles
#Plot all variabls in detail.  Empty vs filled, number of new vesicles,
#number of released vesicles

#Change the strengts of two inputs and see
#how the distribution of T_star changes. Activ. and no inh. Activ and some inh.
#More inh than act.  See how statistical properties of T_star change mean std.

#Change the frequency plot all variables.  Benchmarking code against Zahra's.

#Gillespi to choose next reaction: np.random.choice([reactions], 1, p = [pr1, ...])

###############################################################################
###############################################################################                
###############################################################################
#
#                              Libraries
#
###############################################################################
###############################################################################
###############################################################################

import numpy as np
import matplotlib.pyplot as plt

###############################################################################
###############################################################################                
###############################################################################
#
#                              Classes
#
###############################################################################
###############################################################################
###############################################################################


class Neuron:
    """
    Neuron class that takes a dictionary of arguments with keys:
    
    name (str) - The name of the neuron
    n_type (str: ex, inh_v, inh_pr, inh_f, inh_tv, inh_kv) -
                The type of neuron it is: excitatory, voltage inhibitatory,
                vesicle release inhibitatory, etc... 
    M (int) - number of docked vesicles
    E (int) - number of empty vesicles
    k (float)
    pr (float)
    f (float: between 0 and 1)
    vth (float)
    tv (float)
    kv (float)
    other (dictionary: key/values "pr":(percentage), "f":(percentage), "tv":(float), "kv":(float))


      The names of the attributes will be:

        self.name, self.n_type, self.M, self.E, self.k,
        self.pr, self.f, self.v0, 
        self.vth, self.tv, self.kv, 
        self.AP_length, self, refractory_period,
        self.A, self.tau, self.other
    
    """
    def __init__(self, neuron_args, n_tests):

        #Create all class attributes from the neuron_args dictionary.
        self.__dict__.update((k, v) for k, v in neuron_args.items())

##  The names of the attributes will be:
##
##        self.name, self.n_type, self.M, self.E, self.k,
##        self.pr, self.f, self.v0, 
##        self.vth, self.tv, self.kv, 
##        self.AP_length, self, refractory_period,
##        self.A, self.tau, self.other
##        

        self.n_tests = n_tests


        
        
        #
        self.refractory_period_counter = 0
        #Incase the neuron is inhibited with effects, keep a copy of the original values
        self.pr_original = self.pr
        self.f_original = self.f
        self.tv_original = self.tv
        self.kv_original = self.kv

        #Triggers that prevent an inhibition from producing an increasing effect
        self.pr_changed = False
        self.f_changed = False
        self.tv_changed = False
        self.kv_changed = False

        #Initialize empty connection dictionary
        self.pre_connections = {}
        self.post_connections = {}

        
#

        self.counting_neuron = False
        self.T_star_count = []

        #Marker for when the neuron receives an AP within the refractory period.
        self.initializing_AP_neuron = False
        

        #Dictionary that collects all the voltage values from each preneuron.
        self.voltage_sum = {}

        #Markers for when a neuron has received or fired an action potential.
        self.received_an_AP = False
        self.fired_an_AP = False

        

        self.preneuron_voltage_contributions = {}
        self.queue_size = self.AP_length
        self.voltage_queue = Queue(self.queue_size)
        self.voltage_history = []


        #Vesicle history
        self.E_history = [self.E]
        self.b_history = [0]


#


    
    def pre(self):
        #Return pre_neuron connections
        return self.pre_connections
    
    def post(self):
        #Return post_neuron connections
        return self.post_connections

    def add_pre(self, N):
        #Add a neuron to the pre_connection_list
        self.pre_connections[N.name] = N
        self.preneuron_voltage_contributions[N.name] = Queue(self.AP_length)
        self.voltage_sum[N.name] = 0

    
    def add_post(self, N):
        #Add a neuron to the post_connection list
        self.post_connections[N.name] = N

    def display_queues(self):
        """
        Display all the voltage contrabution queues for the neuron.
        """
        print(self.name) 
        for q in self.preneuron_voltage_contributions.keys():
            print('\t',q, np.around(self.preneuron_voltage_contributions[q].convert_to_list(), 3))

    def fired_AP_check(self):
        if self.fired_an_AP == True:
            for preneuron_name in self.preneuron_voltage_contributions.keys():
                self.preneuron_voltage_contributions[preneuron_name].reset()
        #print('FIRED {}'.format(self.name))


    def no_AP(self):
        
        #If no action potential was received this instance, it will leak voltage
        if self.refractory_period_counter >= 1:
            self.refractory_period_counter -= 1

        for name in self.preneuron_voltage_contributions.keys():
            self.preneuron_voltage_contributions[name].rotate_positions()
            self.voltage_sum[name] = self.preneuron_voltage_contributions[name].positions_dict['p0']
        self.fired_an_AP = False
        
    def voltage(self):
        """
        Return the current voltage of the neuron
        as the sum of the voltage contributions.
        """
        voltage_number = sum([self.voltage_sum[name] for name in self.voltage_sum.keys()])
        return round(voltage_number, 3)
                
    def AP(self):

        if self.initializing_AP_neuron == True:
            self.refractory_period_counter = 0
            
        if self.initializing_AP_neuron == False:
            if self.refractory_period_counter == 0:
                self.refractory_period_counter = self.refractory_period
            if self.refractory_period_counter != 0:
                self.refractory_period_counter -= 1           

        for neuron_name in self.preneuron_voltage_contributions.keys():
            self.voltage_sum[neuron_name] = 0
        #Generate an presynaptic action potential
        #into the postsynaptic neurons with their associated effects
        
        def update_voltage_contributions(post_neuron):
            #pc stands for post connection aka the post neuron
            

################################################################################

###Original function for display purposes.
##            def AP_function():
##                return self.A * np.exp(-np.arange(self.AP_length)/self.tau)


            def AP_function():
                #THIS IS THE FUNCTION THAT I NEED TO MODIFY WITH ZAHRA'S CODE
            


                
                self.b = np.random.binomial(self.M - self.E, self.pr)
                self.b_history.append(self.b)
                
                #This step is further in the code, reset or history function
                #Maybe add a marker
                self.E += self.b
                self.E_history.append(self.E)
                rnum = np.random.uniform(0,1)
                if rnum >= 0.8:
                    refilled_vesicles = np.random.randint(1, self.E+2)
                    self.E_history[-1] -= refilled_vesicles
                    self.E -= refilled_vesicles
                
                new_voltage_shape = self.A * self.kv * self.b * \
                            np.exp(-np.arange(self.AP_length)/self.tau)
                return new_voltage_shape

################################################################################


            #Rotate the voltage queues
            #Update the values with an action potential
            #Add the voltage contribuiton to the voltage sum
            post_neuron.preneuron_voltage_contributions[self.name].rotate_positions()
            if post_neuron.refractory_period_counter == 0:
                post_neuron.preneuron_voltage_contributions[self.name].update_values(AP_function())
            post_neuron.voltage_sum[self.name] = post_neuron.preneuron_voltage_contributions[self.name].positions_dict['p0']
    
            if post_neuron.refractory_period_counter == 0:
                post_neuron.received_an_AP = True


        #AP code
 
        if self.n_type == 'ex':

            for post_neuron_name in self.post_connections.keys():
                update_voltage_contributions(self.post_connections[post_neuron_name])

        #Directly changes the voltage of the neuron    
        if self.n_type == 'inh_v':

            for name in self.post_connections.keys():
                update_voltage_contributions(self.post_connections[name])


        if self.n_type == 'inh_pr':

            for name in self.post_connections.keys():
                if self.post_connections[name].pr_changed == False:
                    self.post_connections[name].pr *= self.other['pr']
                    self.post_connections[name].pr_changed = True
                update_voltage_contributions(self.post_connections[name])

        self.fired_an_AP = True
        
            
                
    def describe(self):
        
        """
        Describe all the information about the neuron
        Print out every attribute.
        """

        for k in self.__dict__.keys():
            print(k + ': {}'.format(self.__dict__[k]))

        
class Queue:
    
    def __init__(self, q_size):
        self.q_size = q_size
        
        self.positions_dict = {'p{}'.format(i):0 for i in range(self.q_size)}

    def rotate_positions(self):
        for i in range(len(self.positions_dict.keys()) - 1):
            self.temp = self.positions_dict['p{}'.format(i+1)]
            self.positions_dict['p{}'.format(i)] = self.temp
        self.positions_dict['p{}'.format(self.q_size - 1)] = 0
        del self.temp
        #Set i to 0 in Position(i) above

    def display_values(self):
        return self.__dict__

    def convert_to_list(self):
        return [self.positions_dict['p{}'.format(i)] for \
                i in range(len(self.positions_dict.keys()))]

    def set_values(self, values):
        for i in range(len(values)):
            self.positions_dict['p{}'.format(i)] = values[i]
            
    def update_values(self, values):
        for i in range(len(values)):
            self.positions_dict['p{}'.format(i)] += values[i]
            
    def reset(self):
        for i in range(self.q_size):
            self.positions_dict['p{}'.format(i)] = 0      

###Queue tests
##q = Queue(10)
##
##qq = q.convert_to_list()
##
##q.display_values()
##q.rotate_positions()
##q.display_values()
##
##q.set_values(range(10))
##q.display_values()
##q.reset()
##q.display_values()
##        
##        
        
        
                
###############################################################################
###############################################################################                
###############################################################################
#
#                              Functions
#
###############################################################################
###############################################################################
###############################################################################

        
def get_dict(**x):
    """
    Function that makes it easy to define a dictionary.
    """
    return x

def neuron_args_check(args_dict_list, template_args):
    """
    Check to see if all the neuron argument
    dictionaries are in the right format.
    """
    for i, dictionary in enumerate(args_dict_list):
        if dictionary.keys() != template_args.keys():
            raise Exception('\n\nDictionary {} is not in the '.format(i)+\
                    'right form.\n\nIt has these keys:\n\n{}\n\nIt should have these keys:\n\n{}'.format(dictionary.keys(), template_args.keys()))
    return 'All dictionaries are in the appropriate form.'

def make_template(template_names):
    """
    Make the neuron argument dictionary template
    in order to check to see if the created neuron
    argument dictionaries have the same keys as the template.]
    """
    template = {}
    for name in template_names[:-1]:
        template[name] = None
    template[template_names[-1]] = {}
    return template

def make_pre_post_connections(connection_list):
    """

    Connect a presynaptic neuron (pre_n) to a postsynaptic neuron (post_n).

    Takes a list of length 2 lists.
    In length 2 list, the first element is the presynaptic neuron,
    and the second element is the postsynaptic neuron.
    
    """
    for i in range(len(connection_list)):

        if (type(connection_list[i][0]) != list) and (type(connection_list[i][1]) \
                                                      != list):
                pre_n = connection_list[i][0]
                post_n = connection_list[i][1]
                pre_n.add_post(post_n)
                post_n.add_pre(pre_n)
                    
        if (type(connection_list[i][0]) == list) and (type(connection_list[i][1]) \
                                                      == list):
            for j in range(len(connection_list[i][0])):
                for k in range(len(connection_list[i][1])):
                    pre_n = connection_list[i][0][j]
                    post_n = connection_list[i][1][k]
                    pre_n.add_post(post_n)
                    post_n.add_pre(pre_n)
                    
        if (type(connection_list[i][0]) == list) and (type(connection_list[i][1]) \
                                                      != list):
            post_n = connection_list[i][1]
            for j in range(len(connection_list[i][0])):
                pre_n = connection_list[i][0][j]
                pre_n.add_post(post_n)
                post_n.add_pre(pre_n)
                
        if (type(connection_list[i][0]) != list) and (type(connection_list[i][1]) \
                                                      == list):
            
            pre_n = connection_list[i][0]
            for j in range(len(connection_list[i][1])):
                post_n = connection_list[i][1][j]
                pre_n.add_post(post_n)
                post_n.add_pre(pre_n)



def generate_AP_times(p_array, n_tests):
    """

    Function that generates the arrival
    of action potentials in a particular instant.

    Arguments
    ---------
    
    p-array : (array_like) 
               Each entry is a probability  of occurance for
               the neuron action potential firing
    n_tests : (int)
              The number of total tests to run.
    

    Returns
    -------

    reactions_array : (array-like)
                        A numpy array of the shape (n_tests,len(p_array))
                        reactions_array[i] is the ith set of firing preneurons.
                        
    """
    reactions_array = np.zeros((len(p_array), n_tests))
    for j in range(n_tests):
        x = np.random.uniform(0,1)
        for i in range(len(p_array)):
            if x <= p_array[i]:
                reactions_array[i][j] = 1
            else:
                reactions_array[i][j] = 0
                
    return reactions_array.astype(int).T

def generate_test_neurons(n, n_args_test):
    test_args = n_args_test.copy()
    neuron_dict = {}
    for i in range(1, n+1):
        test_args['name'] = 'n{}'.format(i)
        neuron_dict[i] = Neuron(test_args, n_tests)
        
    return neuron_dict


def update_network(firing_neurons, full_neuron_list, events):
    """
    Firing_neurons is a list of neurons, events is a list of 0's and 1's.
    If the i-th event is a 1, fire firing_neurons[i], otherwise do nothing.
    
    It updates all the post neurons of the firing neurons.

    Arguments
    ---------

    firing_neurons : (list)
                     List of neurons
    events : (list)
            List of 0's and 1's that indicate whether or not firing_neurons[i]
            will fire an action potential or not.


        
    MAY HAVE ISSUES IF NETWORK HAS FEEDBACK LOOPS WITH TOO HIGH A VOLTAGE
    INCREASE SPACED TOO FAR AWAY.

    INFINITE RECURSION        
    
    """


    if len(firing_neurons) != len(events):
        raise Exception('Firing neurons and events are not the same length.')


    #Get all the active firing neurons for this instance.
    active_firing_neurons = []
    for i in range(len(events)):
        if events[i] == 1:
            active_firing_neurons.append(firing_neurons[i])

    #Initiate action potentials from the active firing neurons.
    #If post neurons after the pre neuron AP's reach a voltage over the threshold
    #then initiate action potentials in those neurons and set their voltages to 0.
    new_firing_neurons = set()
    neurons_that_received_APs = set()
    for FN in active_firing_neurons:
        FN.AP()

        #Add all the post neurons to the set of neurons that received APs
        for post_neuron_name in FN.post().keys():
            neurons_that_received_APs.add(post_neuron_name)
            

        #Add all post neurons that are over their thresholds to a set
        for post_neuron_name in FN.post().keys():

            post_neuron = FN.post()[post_neuron_name]
            if post_neuron.voltage() >= post_neuron.vth:
                new_firing_neurons.add(post_neuron_name)

    new_firing_neurons = set([neuron for neuron in full_neuron_list if (neuron.name in new_firing_neurons)])
    if new_firing_neurons != set():
        new_firing_neurons = list(new_firing_neurons)
        new_events = np.ones(len(new_firing_neurons))

        update_network(new_firing_neurons, full_neuron_list, new_events) #Recursive step.
        for neuron in new_firing_neurons:
            neuron.fired_AP_check()


##p_array = [0.2, 0.5, 0.8] 
##n_tests = 1000
##a = generate_AP_times(p_array, n_tests) #a[i] is the i-th instance of time


def continue_no_AP_neurons(full_neuron_list):
    """
    All the neurons that didn't get an action potential have their
    voltage contribution queues rotated.
    """
    for neuron in full_neuron_list:
        if neuron.received_an_AP == False:
            neuron.no_AP()
        neuron.received_an_AP = False

def initiate_APs_in_network(firing_neurons, event, full_neuron_list):
    """

    Groups together two functions:(1).update_network, and
    (2.) continue_no_AP_neurons and calls them sequentially.

    """

    if len(firing_neurons) != len(event):
        exception_str = 'Firing neuron list and events are not same length.'
        raise Exception(exception_str)
    
    update_network(firing_neurons, full_neuron_list, event)
    continue_no_AP_neurons(full_neuron_list)

    #Update the histories
    
    for neuron in set(full_neuron_list) - set(firing_neurons):
        if neuron.fired_an_AP == False:
            neuron.voltage_history.append(neuron.voltage())
            if neuron.counting_neuron == True:
                neuron.T_star_count.append(0)
        else:
            neuron.voltage_history.append(neuron.vth)
            if neuron.counting_neuron == True:
                neuron.T_star_count.append(1)
 
def merge_dicts(*args):
    my_dict = {}
    for arg in args:
        my_dict.update(arg)
    return my_dict

def generate_poisson_times(AP_rate):
    #Generates AP times at 200-300 per second, returns times in milliseconds
    AP_rate = np.random.randint(200, 301)
    AP_times = np.cumsum(np.random.exponential( 1./AP_rate, size = int(AP_rate)))
    AP_times = np.around(AP_times,3)
    return AP_times


def generate_AP_times_2(p_array, n_tests):
    times_list = []
    for p in p_array:
        times = np.random.choice([0,1],
                                 size = (n_tests),
                                 p = [1-p, p])
        times_list.append(times)

    return np.array(times_list).T        
    
def get_T_star(T_star_list):
    """
    Takes a T_star_list, which is a list of 0's and 1's, and counts the
    number of 0's until a 1 occurs.  Returns the total number of counts
    between each 1 occurance.
    """

    T_star = []
    counter = 0
    for i in range(len(T_star_list)):
        if T_star_list[i] == 0:
            counter += 1
        else:
            counter += 1
            T_star.append(counter)
            counter = 0
    return T_star

def neuron_dict(**my_dict):
    """

    A dictionary of arguments that modify a template neuron dictionary.
    Raises an exception if you include a key that isn't in the
    template dictionary.  Used for quickly changing neuron parameters.
    
    """
    template_dict = get_dict(name = 'template', n_type = 'ex', M = 10, E = 5,
                        k = 1, pr = 0.5, f = 1, v0 = 0,
                       vth = 0.2, tv = 10, kv = 0.01, AP_length = 100,
                     refractory_period = 3, A= 1, tau = 10, other = None)
    for name in my_dict.keys():
        if name not in template_dict.keys():
            raise Exception('Incorrect dictionary key: {}'.format(name))

    for name in my_dict.keys():
        template_dict[name] = my_dict[name]
        
    return template_dict
    

###############################################################################
###############################################################################                
###############################################################################
#
#                                Code
#
###############################################################################
###############################################################################
###############################################################################

n_tests = 100

timer = 0


#Create neuron argument template for checking to see if arguments are correct
template_names = ['name', 'n_type', 'M', 'E', 'k',
                  'pr', 'f', 'v0', 'vth', 'tv', 'kv', 'v',
                  'AP_length','refractory_period', 'A','tau', 'other']
template_args = make_template(template_names)

# Test 1

#Create 4 neurons: An excitatory neuron (ex), and inhibitory neuron 
#effecting the probability of release of (ex), an inhibitory neuron (inh_v)
#to effect a postsynaptic neuron (post)

#Excitatory neuron dictionary
n_args_ex = get_dict(name = 'ex_1', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 10, tv = 10, kv = 0.01, v = 0, AP_length = 10,
                     refractory_period = 3, A= 1, tau = 10, other = None)

#other dictionary for the inhibitory neuron that causes a 20% release
#in the pr variable of the postsynaptic neurons it innervates.
inh_dict = {'pr': 0.8} 
n_args_inh_v = get_dict(name = 'inh_1', n_type = 'inh_v', M = 10, E = 5,
                        k = 1, pr = 0.5, f = 1, v0 = 0, vth = 20, tv = 10,
                        kv = 0.01, v = 0, AP_length = 10, refractory_period = 3,
                        A = 1, tau = 10, other = inh_dict)

n_args_post_inh_pr = get_dict(name = 'inh_1', n_type = 'inh_pr', M = 10, E = 5,
                        k = 1, pr = 0.5, f = 1, v0 = 0, vth = 20, tv = 10,
                        kv = 0.01, v = 0, AP_length = 10, refractory_period = 3,
                        A = 1, tau = 10, other = inh_dict)
n_args_post_inh_pr_2 = get_dict(name = 'inh_2', n_type = 'inh_pr', M = 10, E = 5,
                        k = 1, pr = 0.5, f = 1, v0 = 0, vth = 20, tv = 10,
                        kv = 0.01, v = 0, AP_length = 10, refractory_period = 3,
                        A = 1, tau = 10, other = inh_dict)
n_args_post_inh_pr_3 = get_dict(name = 'inh_3', n_type = 'inh_pr', M = 10, E = 5,
                        k = 1, pr = 0.5, f = 1, v0 = 0, vth = 20, tv = 10,
                        kv = 0.01, v = 0, AP_length = 10, refractory_period = 3,
                        A = 1, tau = 10, other = inh_dict)


n_args_post_inh_pr_4 = get_dict(name = 'inh_4', n_type = 'inh_pr', M = 10, E = 5,
                        k = 1, pr = 0.5, f = 1, v0 = 0, vth = 20, tv = 10,
                        kv = 0.01, v = 0, AP_length = 10, refractory_period = 3,
                        A = 1, tau = 10, other = inh_dict)



##bad_dict = get_dict(bad1 = None, bad2 = None)
##bad_args_dict_list = [neuron_args1, neuron_args2, bad_dict]
##
###Check to make sure all neuron parameters are in the correct form.
###CODE WILL RAISE AN ERROR HERE
##neuron_args_check(bad_args_dict_list, template_args)

#Code works here
args_dict_list = [n_args_ex, n_args_inh_v, n_args_post_inh_pr]
neuron_args_check(args_dict_list, template_args)


#Create the two neurons
N_ex = Neuron(n_args_ex, n_tests)
N_inh_v = Neuron(n_args_inh_v, n_tests)
N_post_inh_pr = Neuron(n_args_post_inh_pr, n_tests)

#Connections : 2-(1), 3-(1)
connection_list = [[N_ex, N_post_inh_pr], [N_inh_v, N_post_inh_pr],
                   [N_post_inh_pr, N_ex]]
make_pre_post_connections(connection_list)


N1 = Neuron(n_args_ex, n_tests)
N2 = Neuron(n_args_post_inh_pr, n_tests)
N3 = Neuron(n_args_post_inh_pr_2, n_tests)
make_pre_post_connections([[[N2, N3], N1]])

N2.AP()
N3.AP()
N1.preneuron_voltage_contributions

#Test 1 : END




# Test 2 : Connecting N2 to N1 and N3
N1 = Neuron(n_args_ex, n_tests)
N2 = Neuron(n_args_post_inh_pr, n_tests)
N3 = Neuron(n_args_post_inh_pr_2, n_tests)
N4 = Neuron(n_args_post_inh_pr_3, n_tests)
N5 = Neuron(n_args_post_inh_pr_4, n_tests)
make_pre_post_connections([[N2, N1], [N2, N3]])
N2.AP()
N1.describe()
N3.describe()
# Test 2 : End






#Test 3 : update voltages sequentially.  Connections: 1-(3,4), 2-(4,5)
args_dict_list = [n_args_ex, n_args_post_inh_pr,
                  n_args_post_inh_pr_2, n_args_post_inh_pr_3,
                  n_args_post_inh_pr_4]

neuron_args_check(args_dict_list, template_args)

p_array = [0.8, 0.8] 
n_tests = 1000
#a[i] is the i-th instance of time
reaction_times = generate_AP_times(p_array, n_tests) 

N1 = Neuron(n_args_ex, n_tests)
N2 = Neuron(n_args_post_inh_pr, n_tests)
N3 = Neuron(n_args_post_inh_pr_2, n_tests)
N4 = Neuron(n_args_post_inh_pr_3, n_tests)
N5 = Neuron(n_args_post_inh_pr_4, n_tests)
make_pre_post_connections([[N1, [N3, N4]],[N2, [N4, N5]]])

firing_neurons = [N1, N2] #List of firing neurons
print(N3.v, N4.v, N5.v)
print(N4.display_queues())

N4.no_AP()
N3.no_AP()
N5.no_AP()
print(N3.v, N4.v, N5.v)
N3.display_queues()

#Updates all the post neurons in the firing network.
update_network(firing_neurons, [1,1]) 
print(N3.v, N4.v, N5.v)
print(N3.display_queues())



#
n_args_N1 = get_dict(name = 'N1', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 3, tv = 10, kv = 0.01, v = 0, AP_length = 10,
                     refractory_period = 3, A= 1, tau = 10, other = None)
n_args_N2 = get_dict(name = 'N2', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 3, tv = 10, kv = 0.01, v = 0, AP_length = 10,
                      refractory_period = 3, A= 1, tau = 10, other = None)
N1 = Neuron(n_args_N1, n_tests)
N2 = Neuron(n_args_N2, n_tests)
make_pre_post_connections([[N1, N2]])
firing_neurons = [N1]
n_list = [N1, N2]

print(N2.v)
N2.display_queues()

update_network(firing_neurons, [1])
continue_no_AP_neurons(n_list)
print(N2.voltage_sum)
N2.display_queues()

update_network(firing_neurons, [0])
continue_no_AP_neurons(n_list)
N2.display_queues()

#

#SEEMS LIKE IT ADDS TOO MUCH VOLTAGE EACH TIME, MUST FIND HOW TO REDUCE IT

#Test 3 : End  


###############################################################################
###############################################################################                
###############################################################################
#
#                              Network test: 12, 345, 67, 8
#
###############################################################################
###############################################################################
###############################################################################


p_array = [0.5, 0.2] 
n_tests = 1000
#a[i] is the i-th instance of time
reaction_times = generate_AP_times(p_array, n_tests) 

n_args_test = get_dict(name = 'ex_1', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 3, tv = 10, kv = 0.01, v = 0, AP_length = 10,
                     refractory_period = 3, A= 1, tau = 10, other = None)


n_test_neurons = 8
#8 test neurons, modeled after n_args_ex
tn = generate_test_neurons(n_test_neurons, n_args_test) 
full_neuron_list = [tn[i] for i in range(1,n_test_neurons+1)]

c1 = [tn[1], [tn[3], tn[4]]]
c2 = [tn[2], [tn[4], tn[5]]]
c3 = [[tn[3], tn[4]], tn[6] ]
c4 = [[tn[4], tn[5]], tn[7]]
c5 = [[tn[6], tn[7]], tn[8]]

connection_list = [c1, c2, c3, c4, c5]


make_pre_post_connections(connection_list)

firing_neurons = [tn[1], tn[2]]

#THIS IS BETTER, BUT I NEED TO NOW CODE THIS SO THAT THE UPDATES WILL
#DISPLAY VOLTAGES WHEN ACTION POTENTIALS HIT.
#Maybe I need to update the preneuron_voltage_contribution in the
#AP or the big function since it just deals with v and not the queues.

initiate_APs_in_network(firing_neurons, [1,1], full_neuron_list)

##for neuron in full_neuron_list:
##    print(neuron.name, neuron.voltage())
##
print(tn[3].voltage(), tn[4].voltage(), tn[5].voltage(), '\n ',
          tn[6].voltage(), tn[7].voltage(), '\n  ', tn[8].voltage())

##
##for i in range(20):
##    update_network(firing_neurons, reaction_times[i])
##    continue_no_AP_neurons(full_neuron_list)
##    print('-----\nReaction({}):{}\n '.format(i,reaction_times[i]), tn[3].voltage(),
##          tn[4].voltage(), tn[5].voltage(), '\n ',
##          tn[6].voltage(), tn[7].voltage(), '\n  ', tn[8].voltage())
##

###############################################################################
###############################################################################                
###############################################################################
#
#                                Feedback Test
#
###############################################################################
###############################################################################
###############################################################################

p_array = [0.5, 0.2] 
n_tests = 1000

#a[i] is the i-th instance of time
reaction_times = generate_AP_times(p_array, n_tests) 

n_args_test = get_dict(name = 'ex_1', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 3.5, tv = 10, kv = 0.01, v = 0, refractory_period = 3,
                       AP_length = 15, A= 1.2, tau = 50, other = None)

#8 test neurons, modeled after n_args_ex
n_test_neurons = 8
tn = generate_test_neurons(n_test_neurons, n_args_test) 
full_neuron_list = [tn[i] for i in range(1,n_test_neurons+1)]

c1 = [tn[1], [tn[3], tn[4]]]
c2 = [tn[2], [tn[4], tn[5]]]
c3 = [[tn[3], tn[4]], tn[6] ]
c4 = [[tn[4], tn[5]], tn[7]]
c5 = [[tn[6], tn[7]], tn[8]]
c6 = [tn[8], tn[3]]

connection_list = [c1, c2, c3, c4, c5, c6]


make_pre_post_connections(connection_list)

firing_neurons = [tn[1], tn[2]]

#THIS IS BETTER, BUT I NEED TO NOW CODE THIS SO THAT THE UPDATES WILL
#DISPLAY VOLTAGES WHEN ACTION POTENTIALS HIT.
#Maybe I need to update the preneuron_voltage_contribution in the
#AP or the big function since it just deals with v and not the queues.

initiate_APs_in_network(firing_neurons, [1,1], full_neuron_list)

##for neuron in full_neuron_list:
##    print(neuron.name, neuron.voltage())

print(tn[3].voltage(), tn[4].voltage(), tn[5].voltage(), '\n ',
          tn[6].voltage(), tn[7].voltage(), '\n  ', tn[8].voltage())


##for i in range(20):
##    update_network(firing_neurons, reaction_times[i])
##    continue_no_AP_neurons(full_neuron_list)
##    print('-----\nReaction({}):{}\n '.format(i,reaction_times[i]),
##          tn[3].voltage(), tn[4].voltage(), tn[5].voltage(), '\n ',
##          tn[6].voltage(), tn[7].voltage(), '\n  ', tn[8].voltage())

###############################################################################
###############################################################################                
###############################################################################
#
#                                Feedback Test 2
#
###############################################################################
###############################################################################
###############################################################################

p_array = [0.5, 0.2] 
n_tests = 1000

#a[i] is the i-th instance of time
reaction_times = generate_AP_times(p_array, n_tests) 

n_args_test = get_dict(name = 'ex_1', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 3, tv = 10, kv = 0.01, v = 0, refractory_period = 3,
                       AP_length = 10, A= 1.4, tau = 10, other = None)

#8 test neurons, modeled after n_args_ex
n_test_neurons = 6
tn = generate_test_neurons(n_test_neurons, n_args_test) 
full_neuron_list = [tn[i] for i in range(1,n_test_neurons+1)]

c1 = [tn[1], tn[2]]
c2 = [tn[2], tn[3]]
c3 = [tn[3], tn[4]]
c4 = [tn[4], tn[5]]
c5 = [tn[6], tn[5]]
c_fb = [tn[5], tn[4]]

connection_list = [c1, c2, c3, c4,  c5, c_fb]

make_pre_post_connections(connection_list)

firing_neurons = [tn[1], tn[6]]

#THIS IS BETTER, BUT I NEED TO NOW CODE THIS SO THAT THE UPDATES WILL
#DISPLAY VOLTAGES WHEN ACTION POTENTIALS HIT.
#Maybe I need to update the preneuron_voltage_contribution in the
#AP or the big function since it just deals with v and not the queues.

initiate_APs_in_network(firing_neurons, [1, 1], full_neuron_list)

##for neuron in full_neuron_list:
##    print(neuron.name, neuron.voltage())

print('', tn[2].name, tn[2].voltage(), '\n', tn[3].name, tn[3].voltage(),
      '\n', tn[4].name, tn[4].voltage(), '\n', tn[5].name, tn[5].voltage())
tn[2].display_queues()
tn[3].display_queues()




##for i in range(20):
##    update_network(firing_neurons, reaction_times[i])
##    continue_no_AP_neurons(full_neuron_list)
##    print('-----\nReaction({}):{}\n '.format(i,reaction_times[i]),
##          tn[3].voltage(), tn[4].voltage(), tn[5].voltage(), '\n ',
##          tn[6].voltage(), tn[7].voltage(), '\n  ', tn[8].voltage())

###############################################################################
###############################################################################                
###############################################################################
#
#                                Feedback Test 3
#
###############################################################################
###############################################################################
###############################################################################

p_array = [0.5, 0.2] 
n_tests = 1000

#a[i] is the i-th instance of time
reaction_times = generate_AP_times(p_array, n_tests) 

n_args_test = get_dict(name = 'ex_1', n_type = 'ex', M = 10, E = 5, k = 1,
                       pr = 0.5, f = 1, v0 = 0,
                       vth = 3, tv = 10, kv = 0.01, v = 0, refractory_period = 3,
                       AP_length = 10, A= 1, tau = 10, other = None)

#8 test neurons, modeled after n_args_ex
n_test_neurons = 8
tn = generate_test_neurons(n_test_neurons, n_args_test) 
full_neuron_list = [tn[i] for i in range(1,n_test_neurons+1)]

c1 = [tn[1], tn[3]]
c2 = [tn[2], tn[4]]
c3 = [[tn[3], tn[4]], tn[5]]
c4 = [tn[5], tn[6]]
c5 = [tn[6], tn[7]]
c6 = [tn[8], tn[7]]
c_fb = [tn[7], [tn[5], tn[3]]]


connection_list = [c1, c2, c3, c4,  c5, c6, c_fb]

make_pre_post_connections(connection_list)

firing_neurons = [tn[1], tn[2], tn[8]]

#THIS IS BETTER, BUT I NEED TO NOW CODE THIS SO THAT THE UPDATES WILL
#DISPLAY VOLTAGES WHEN ACTION POTENTIALS HIT.
#Maybe I need to update the preneuron_voltage_contribution in the
#AP or the big function since it just deals with v and not the queues.

initiate_APs_in_network(firing_neurons, [1, 1, 1], full_neuron_list)

##for neuron in full_neuron_list:
##    print(neuron.name, neuron.voltage())

print('', tn[3].name, tn[3].voltage(), '  ', tn[4].voltage(), tn[4].name,
      '\n', tn[5].name, ' ', tn[5].voltage(),
      '\n', tn[6].name, ' ',tn[6].voltage(), '\n', tn[7].name,' ',
      tn[7].voltage(), '\n')
tn[5].display_queues()
tn[6].display_queues()

for neuron in full_neuron_list:
    print('', neuron.name, neuron.voltage())




##for i in range(20):
##    update_network(firing_neurons, reaction_times[i])
##    continue_no_AP_neurons(full_neuron_list)
##    print('-----\nReaction({}):{}\n '.format(i,reaction_times[i]),
##          tn[3].voltage(), tn[4].voltage(), tn[5].voltage(), '\n ',
##          tn[6].voltage(), tn[7].voltage(), '\n  ', tn[8].voltage())


###############################################################################
###############################################################################                
###############################################################################
#
#                                Final Test
#
###############################################################################
###############################################################################
###############################################################################


#n_tests = 1000 means 1000 ms which is 1 second, 100000 means us
n_tests = 500

p_array = [0.6, 0.1]

reaction_times = generate_AP_times(p_array, n_tests)


template_names = ['name', 'n_type', 'M', 'E', 'k',
                  'pr', 'f', 'v0', 'vth', 'tv', 'kv',
                  'AP_length','refractory_period', 'A','tau', 'other']
template_args = make_template(template_names)


N_ex_dict = neuron_dict(name = 'N_ex', n_type = 'ex', M = 10, E = 5, pr = 0.6,
                        kv = 0.02)
N_inh_dict = neuron_dict(name = 'N_inh',n_type='inh_v',M = 10, E = 5, pr = 0.3,
                         A = -1)
N_post_dict = neuron_dict(name = 'N_post',n_type='ex',M = 10, E = 5, pr = 0.3)
N_post_dict_2 = neuron_dict(name = 'N_post_2',n_type='ex',M = 10, E = 5,
                            pr = 0.3)


args_dict_list = [N_ex_dict, N_inh_dict, N_post_dict, N_post_dict_2]
neuron_args_check(args_dict_list, template_args)

N_ex = Neuron(N_ex_dict, n_tests)
N_inh = Neuron(N_inh_dict, n_tests)
N_post = Neuron(N_post_dict, n_tests)
N_post_2 = Neuron(N_post_dict_2, n_tests)

N_post.counting_neuron = True

c1 = [[N_ex, N_inh], [N_post]]
c2 = [[N_post], [N_post_2]]

connections = [c1, c2]
make_pre_post_connections(connections)

full_neuron_list = [N_ex, N_inh, N_post, N_post_2]
firing_neurons = [N_ex, N_inh]


###Individal AP firing test

##initiate_APs_in_network(firing_neurons, [1,1], full_neuron_list)
##
##print(N_post.voltage())
##print(N_post.fired_an_AP)
##print(N_post.refractory_period_counter)
##N_post.display_queues()
##
##print('\n')
##print(N_post_2.voltage())
##N_post_2.display_queues()
#


#Main test

for i in range(n_tests):
    initiate_APs_in_network(firing_neurons, reaction_times[i], full_neuron_list)

#Plot the firing times of the firing neurons.


##fire_times_ex = reaction_times[:, 0]
##fire_times_inh = reaction_times[:,1]
##
##f_times = [i for i,v in enumerate(fire_times_ex) if (v ==1)]

fig, ax = plt.subplots(2,1)

fig.suptitle('Firing Times (In {} second)'.format(n_tests/1000))

ex_times = [i for i,v in enumerate(reaction_times[:,0]) if (v==1)]
inh_times = [i for i,v in enumerate(reaction_times[:,1]) if (v==1)]

ax[0].set_title('N_ex')
ax[0].set_xticklabels([])
ax[0].set_yticklabels({})
ax[0].vlines(ex_times, ymin = 0, ymax = 1,
             label = 'ex: {}'.format(np.sum(reaction_times[:, 0])))
ax[0].plot([3]) #Raise the graph up a litte
ax[0].legend()


ax[1].set_title('N_inh')
ax[1].set_xlabel('Time Instance (ms)')
ax[1].set_yticklabels([])
ax[1].vlines(inh_times, ymin = 0, ymax = 1,
             label = 'ex: {}'.format(np.sum(reaction_times[:, 1])))
ax[1].plot([3])
ax[1].legend()

plt.legend()
plt.show()




#Plot the post neuron graphs

fig, ax = plt.subplots(2,1)

ax[0].plot(N_post.voltage_history)
ax[0].plot(N_post.vth * np.ones(n_tests))
ax[0].set_title('N_post voltage history')
ax[0].set_ylabel('Voltage')
ax[0].set_xticklabels([])

ax[1].plot(N_post_2.voltage_history)
ax[1].plot(N_post_2.vth * np.ones(n_tests))
ax[1].set_title('N_post_2 voltage history')
ax[1].set_xlabel('Time Instance (ms)')
ax[1].set_ylabel('Voltage')
plt.show()


#T_star plot

T_star = get_T_star(N_post.T_star_count)
plt.title('T_star plot')
plt.plot(T_star, label = 'T_star')
plt.xlabel('AP instance')
plt.ylabel('Time (ms)')
plt.plot(np.mean(T_star) * np.ones(len(T_star)), label = 'T_star mean = {}'.format(np.around(np.mean(T_star)), 3))
plt.legend()
plt.show()

#Vesicle plot
fig, ax = plt.subplots(2,1)
ax[0].set_title('Vesicle release ')
ax[0].plot(N_ex.E_history, label = 'E', c='r')
ax[0].set_xticklabels([])
ax[0].plot(np.zeros(len(N_ex.E_history)))
ax[1].set_title('Vesicle Empty')
ax[1].plot(N_ex.b_history, label = 'b')
ax[1].plot(np.zeros(len(N_ex.b_history)))
plt.legend()
plt.show()



    
