import numpy as np

def main():
    input_string = input()
    input_list = [int(x) for x in input_string.split(' ')]

    game_tree = set_up_tree(input_list)

    alpha_beta_prune(game_tree)

    output_string = alpha_beta_prune(input_list)
    print_output(input_string, output_string)    

def print_output(input_string, output_string):
    print('Input:\n{}\nOutput:\n{}'.format(input_string,output_string))

def alpha_beta_prune(game_tree):

    

    return output_string

def set_up_tree(input_list):

    root = Node('root')
    nodes_1 = [Node('1_{}'.format(i)) for i in range(3)]
    nodes_2 = [Node('2_{}'.format(i)) for i in range(6)]
    nodes_3 = [Node('3_{}'.format(i)) for i in range(12)]

    for node in nodes_1:
        node.level = 1
    for node in nodes_2:
        node.level = 2
    for node in nodes_3:
        node.level = 3
            
        
    for node in nodes_1:
        node.level = 1

    root.children = nodes_1
    
    for node in nodes_1:
        node.parent = root


    nodes_1[0].children = nodes_3[:2]
    nodes_1[1].children = nodes_3[2:4]
    nodes_1[2].children = nodes_3[4:]

    nodes_2[0].parent = nodes_1[0]
    nodes_2[1].parent = nodes_1[0] 
    nodes_2[2].parent = nodes_1[1]
    nodes_2[3].parent = nodes_1[1]    
    nodes_2[4].parent = nodes_1[2]
    nodes_2[5].parent = nodes_1[2]

    for i in range(6):
        nodes_2[i].children = nodes_3[2*i:2*i + 2]

    nodes_3[0].parent = nodes_2[0]
    nodes_3[1].parent = nodes_2[0]
    nodes_3[2].parent = nodes_2[1]
    nodes_3[3].parent = nodes_2[1]
    nodes_3[4].parent = nodes_2[2]
    nodes_3[5].parent = nodes_2[2]
    nodes_3[6].parent = nodes_2[3]
    nodes_3[7].parent = nodes_2[3]
    nodes_3[8].parent = nodes_2[4]
    nodes_3[9].parent = nodes_2[4]
    nodes_3[10].parent = nodes_2[5]
    nodes_3[11].parent = nodes_2[5]


    for i in range(len(input_list)):
        nodes_3[i].value = input_list[i]
    
    T = Tree(root, nodes_1, nodes_2, nodes_3)
    
    return T

class Node:
    def __init__(self, name):
        self.Name = name
        self.value = None
        self.alpha = None
        self.beta = None
        self.parent = None
        self.children = None
        self.level = None

class Tree:
    def __init__(self, root, l1, l2, l3):
        self.root = root
        self.l1 = l1
        self.l2 = l2
        self.l3 = l3
        
        
    
main()


class game:
    def __init__(self):
        pass

    def actions(self, state):
        state_children = state.children
            
    def is_terminal(self, state):
        if state.level == 3:
            return True
        else:
            return False

    def result(self, state, a):
        pass
    def utility(self, state, player):
        pass

    def to_move(self, state):
        if (state.level == 1) or (state.level == 3):
            return "Max"
        else:
            return 'Min'
    


def alpha_beta_search(game, state):
    player = game.to_move(state)
    value, move = max_value(game, state, -np.inf, np.inf)
    return move

def max_val(game, state, alpha, beta):
    if game.is_terminal(state):
        return game.utility(state,player)
    v = -np.inf
    for a in game.actions(state):
        v2, a2 = min_val(game, game.result(state, a), alpha, beta)
        if v2 > v:
            v, move = v2, a
            alpha = max(alpha, v)
        if v >= beta:
            return v, move
    return v, move

def min_value(game, state, alpha, beta):
    if game.is_terminal(state):
        return game.utility(state, player)
    v = -np.inf
    for a in game.actions(state):
        v2, a2 = max_value(game, game.result(state,a), alpha, beta)
        if v2 < v:
            v, move = v2, a
            veta = min(beta, v)
        if v <= alpha:
            return v, move
    return v,move

