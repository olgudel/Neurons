import numpy as np
import cv2
import matplotlib.pyplot as plt

from scipy.ndimage import gaussian_filter

I = cv2.imread(r'C:\Users\Oliver\Desktop\Homework\2020\2 - Fall 2020\CISC 642 - Computer Vision\ud.jpg', 1)
I = cv2.cvtColor(I, cv2.COLOR_BGR2RGB)
plt.imshow(I)
plt.show()


H = np.array([[1, 1, 1], [1,1,1], [1,1,1]]) * (1/9)


def convolve(img,H):
    image = img.copy()

    channels = []
    for ch in range(image.shape[2]):
        I = image[:, :, ch]
        K_size = H.shape[0]
        frame_addition = int((K_size-1) // 2)
        frame = np.zeros([I.shape[0] + K_size - 1,
                          I.shape[1] + K_size - 1]).astype(np.uint8)
        
        frame[frame_addition: frame_addition + I.shape[0],
              frame_addition : frame_addition + I.shape[1]] = I
        final = frame.copy()

        k = 0
        for i in range(I.shape[0]):
            for j in range(I.shape[1]):
                final[i+frame_addition,j+frame_addition] = \
                                np.sum(H * frame[i:i+K_size, j:j+K_size])
                k += 1
                print(k / I.size*3)
        channels.append(final)
    return np.stack(channels, axis = 2)

result = convolve(I,H)

plt.imshow(result)
plt.show()

def gaussian(sigma, F_size):
    numbers = range(-int((F_size - 1)//2), int((F_size - 1)//2 + 1))
    gauss = lambda x,y,sigma : 1/(2 * np.pi * sigma**2) * np.exp(-(x**2 + y**2)/(2 * sigma**2))

    gauss_kernel = np.zeros((F_size, F_size))
    for i in range(len(numbers)):
        for j in range(len(numbers)):
            gauss_kernel[i,j] = gauss(numbers[i],numbers[j],sigma)
    return gauss_kernel
        
        
def reduce(img, H):
    

