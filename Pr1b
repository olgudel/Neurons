import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

address = r'C:\Users\Oliver\Desktop\Homework\2020\2 - Fall 2020\CISC 642- Computer Vision'

os.chdir(address)

img = cv2.imread('img.jpg', 0)
#img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)


#Created copy so not to modify image
img_mod = img.copy()

def click_function(the_image):
    #Click: UL UR LL LR
    coords = []

    # function to display the coordinates of 
    # of the points clicked on the image  
    def click_event(event, x, y, flags, params): 
      
        # checking for left mouse clicks 
        if event == cv2.EVENT_LBUTTONDOWN: 
      
            # displaying the coordinates 
            # on the Shell 
            coords.append([x,y])
      
            # displaying the coordinates 
            # on the image window 
            font = cv2.FONT_HERSHEY_SIMPLEX 
            cv2.putText(the_image, str(x) + ',' +
                        str(y), (x,y), font, 
                        1, (255, 0, 0), 2) 
            cv2.imshow('image', the_image) 
      
    # displaying the image 
    cv2.imshow('image', the_image) 
      
    # setting mouse hadler for the image 
    # and calling the click_event() function 
    cv2.setMouseCallback('image', click_event) 
      
    # wait for a key to be pressed to exit 
    cv2.waitKey(0) 
      
    # close the window 
    cv2.destroyAllWindows()

    return coords
    

#Perspective
img_mod = img.copy()
coords = click_function(img_mod)

coords2 = click_function(img_mod)
pts2 = np.array(coords2).astype(np.float32)

size_x, size_y = img_mod.shape

pts1 = np.array(coords).astype(np.float32)
##pts2 = np.float32([[0,0],[size_x,0],[0,size_y],[size_x, size_y]])

M_per = cv2.getPerspectiveTransform(pts1,pts2)

dst_per = cv2.warpPerspective(img, M_per, (size_x, size_y))

def make_aff_matrices(pts, pts2):
    aff_matrix = []
    for x,y in pts:
        r1 = [x,y,0,0,1,0]
        r2 = [0,0,x,y,0,1]
        aff_matrix.append(r1)
        aff_matrix.append(r2)

    points_vector = []
    for x,y in pts2:
        points_vector.append(x)
        points_vector.append(y)
    
        
    return np.array(aff_matrix).astype(np.float32), \
           np.array(points_vector).astype(np.float32)


def make_per_matrices(pts, pts2):
    per_matrix = []
    for x,y,u,v in np.hstack([pts, pts2]):
        r1 = [x,y,1,0,0,0,-x*u, -y*u]
        r2 = [0,0,0,x,y,1,-x*v, -y*v]
        per_matrix.append(r1)
        per_matrix.append(r2)

    points_vector = []
    for x,y in pts2:
        points_vector.append(x)
        points_vector.append(y)
    
        
    return np.array(per_matrix).astype(np.float32), \
           np.array(points_vector).astype(np.float32)


def pseudo_inv(A,b):
    return ((np.linalg.inv(A.T@A))@A)@b

matching_1 = click_function(img_mod)
matching_1 = np.array(matching_1).astype(np.float32)
matching_2 = click_function(dst_per)
matching_2 = np.array(matching_2).astype(np.float32)

A,b = make_per_matrices(matching_1, matching_2)

per_matrix = np.linalg.inv(A)@b

plt.suptitle('Perspective: {}'.format(coords))
plt.subplot(121),plt.imshow(img),plt.title('Input')
plt.subplot(122),plt.imshow(dst_per),plt.title('Output')
plt.show()


#Affine
img_mod = img.copy()
coords_1 = click_function()
coords_2 = click_function()
rows,cols, = img.shape

pts1 = np.array(coords_1).astype(np.float32)
pts2 = np.array(coords_2).astype(np.float32)

M_aff = cv2.getAffineTransform(pts1,pts2)

dst_aff = cv2.warpAffine(img,M_aff,(cols,rows))

plt.suptitle('Affine {}'.format(coords))
plt.subplot(121),plt.imshow(img),plt.title('Input')
plt.subplot(122),plt.imshow(dst_aff),plt.title('Output')
plt.show()

################################################################################
#
#                           Problem 2
#
################################################################################

per_matrix = np.matmul(dst_per, np.linalg.inv(img))

U, _, _ np.linalg.svd(result)
min_eig = U[:, -1]
